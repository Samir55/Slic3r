#ifndef slic3r_SupportMaterial_hpp_
#define slic3r_SupportMaterial_hpp_

#include <algorithm>
#include <iostream>
#include <map>
#include <numeric>
#include <utility>
#include <vector>

#include "libslic3r.h"

#include "ClipperUtils.hpp"
#include "ExPolygon.hpp"
#include "Fill/Fill.hpp"
#include "Flow.hpp"
#include "Geometry.hpp"
#include "Layer.hpp"
#include "Polygon.hpp"
#include "Print.hpp"
#include "PrintConfig.hpp"
#include "SVG.hpp"

using namespace std;

namespace Slic3r
{

// how much we extend support around the actual contact area
constexpr coordf_t SUPPORT_MATERIAL_MARGIN = 1.5;

constexpr coordf_t MARGIN_STEP = SUPPORT_MATERIAL_MARGIN / 3;

constexpr coordf_t PILLAR_SIZE = 2.5;

constexpr coordf_t PILLAR_SPACING = 10;

/// Struct for carrying the toolpaths parameters needed for each thread.
struct toolpaths_params
{
    int contact_loops;
    coord_t circle_radius;
    coord_t circle_distance;
    Polygon circle;
    SupportMaterialPattern pattern;
    vector<int> angles;
    int interface_angle{};
    double interface_spacing{};
    float interface_density{};
    double support_spacing{};
    double support_density{};

    explicit toolpaths_params(int contact_loops = 0,
                              coord_t circle_radius = 0,
                              coord_t circle_distance = 0,
                              Polygon circle = Polygon(),
                              const SupportMaterialPattern &pattern = SupportMaterialPattern(),
                              vector<int> angles = vector<int>())
        : contact_loops(contact_loops),
          circle_radius(circle_radius),
          circle_distance(circle_distance),
          circle(std::move(circle)),
          pattern(pattern),
          angles(std::move(angles))
    {}
};

class SupportMaterial
{
public:
    friend PrintObject;

    PrintConfig *config; ///< The print config
    PrintObjectConfig *object_config; ///< The object print config.
    Flow flow; ///< The intermediate layers print flow.
    Flow first_layer_flow; ///< The first (base) layers print flow.
    Flow interface_flow; ///< The interface layers print flow.

    /// Generate the extrusions paths for the support matterial generated for the given print object.
    void generate_toolpaths(PrintObject *object);

    /// Generate support material for the given print object.
    void generate(PrintObject *object);

    /// Generate the support layers slicing z coordinates.
    vector<coord_t> support_layers_z(vector<coord_t> contact_z,
                                     vector<coord_t> top_z,
                                     coord_t max_object_layer_height);

    pair<map<coord_t, Polygons>, map<coord_t, Polygons>> contact_area(PrintObject *object); // DONE

    map<coord_t, Polygons> object_top(PrintObject *object, map<coord_t, Polygons> &contact); // DONE

    void generate_pillars_shape(const map<coord_t, Polygons> &contact,
                                const vector<coord_t> &support_z,
                                map<int, Polygons> &shape); // DONE

    map<int, Polygons> generate_base_layers(vector<coord_t> &support_z,
                                            map<coord_t, Polygons> &contact,
                                            map<int, Polygons> &_interface,
                                            map<coord_t, Polygons> &top); // DONE

    map<int, Polygons> generate_interface_layers(vector<coord_t> &support_z,
                                                 map<coord_t, Polygons> &contact,
                                                 map<coord_t, Polygons> &top);

    void generate_bottom_interface_layers(const vector<coord_t> &support_z,
                                          map<int, Polygons> &base,
                                          map<coord_t, Polygons> &top,
                                          map<int, Polygons> &_interface); // DONE

    coordf_t contact_distance(coordf_t layer_height, coordf_t nozzle_diameter);

    /// This method returns the indices of the layers overlapping with the given one.
    vector<int> overlapping_layers(int layer_idx, const vector<coord_t> &support_z); // DONE

    void clip_with_shape(map<int, Polygons> &support, map<int, Polygons> &shape);

    // This method removes object silhouette from support material
    // (it's used with interface and base only). It removes a bit more,
    // leaving a thin gap between object and support in the XY plane.
    void clip_with_object(map<int, Polygons> &support,
                          vector<coord_t> support_z,
                          PrintObject &object); // DONE Partially

    void process_layer(int layer_id, toolpaths_params params);

private:
    /// SupportMaterial is generated by PrintObject.
    SupportMaterial(PrintConfig *print_config,
                    PrintObjectConfig *print_object_config,
                    Flow flow,
                    Flow first_layer_flow,
                    Flow interface_flow)
        : config(print_config),
          object_config(print_object_config),
          flow(flow),
          first_layer_flow(first_layer_flow),
          interface_flow(interface_flow),
          object(nullptr)
    {}

    // Return polygon vector given a vector of surfaces.
    Polygons p(SurfacesPtr &surfaces);

    // Get the keys of an std::map sorted ascendingly.
    vector<coord_t> keys_sorted(map<coord_t, Polygons> &map_); // DONE

    // Get the maximum layer height given a print object.
    coord_t max_layer_height(PrintObject *object); // DONE

    Polygon create_circle(coord_t radius);

    // Used during generate_toolpaths function.
    PrintObject *object;
    map<coord_t, Polygons> overhang;
    map<coord_t, Polygons> contact;
    map<int, Polygons> _interface;
    map<int, Polygons> base;
    vector<coord_t> support_z;

};

}

#endif

